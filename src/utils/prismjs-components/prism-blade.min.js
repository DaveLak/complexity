Prism.languages.blade = Prism.languages.extend('markup', {
  'directive': {
    pattern: /@[\w]+/,
    alias: 'keyword'
  },
  'variable': {
    pattern: /\{\{.*?\}\}/,
    inside: {
      'punctuation': {
        pattern: /^\{\{|\}\}$/,
        alias: 'punctuation'
      },
      'variable': {
        pattern: /[\s\S]+/,
        alias: 'variable'
      }
    }
  },
  'php': {
    pattern: /<\?php[\s\S]*?\?>/,
    inside: Prism.languages.php
  },
  'path': {
    pattern: /(?:\b(?:include|require|include_once|require_once)\b\s*['"])[^'"]+['"]/,
    inside: {
      'keyword': /(?:include|require|include_once|require_once)/,
      'string': /['"][^'"]+['"]/
    }
  },
  'livewire': {
    pattern: /@(?:js|css|php|livewire)\b/,
    alias: 'keyword'
  },
  'directive_with_args': {
    pattern: /@[\w]+\(['"][^'"]+['"]\)/,
    inside: {
      'directive': /@[\w]+/,
      'string': /['"][^'"]+['"]/
    }
  }
});

Prism.hooks.add('before-tokenize', (env) => {
  if (env.language !== 'blade') return;

  const pattern = /@php[\s\S]*?@endphp|@js[\s\S]*?@endjs|@css[\s\S]*?@endcss/g;
  env.tokenStack = [];
  env.code = env.code.replace(pattern, (match) => {
    env.tokenStack.push(match);
    return `___TOKEN${env.tokenStack.length - 1}___`;
  });
});

Prism.hooks.add('after-tokenize', (env) => {
  if (env.language !== 'blade' || !env.tokenStack) return;

  env.tokenStack.forEach((token, i) => {
    const pattern = /@php([\s\S]*?)@endphp|@js([\s\S]*?)@endjs|@css([\s\S]*?)@endcss/;
    const matches = pattern.exec(token);
    if (matches) {
      const content = matches[1] || matches[2] || matches[3];
      const language = matches[1] ? 'php' : matches[2] ? 'javascript' : 'css';
      env.tokens = env.tokens.map((t) => {
        if (typeof t === 'string' && t.includes(`___TOKEN${i}___`)) {
          return new Prism.Token('directive_with_args', Prism.tokenize(content, Prism.languages[language]), `language-${language}`, token);
        }
        return t;
      });
    }
  });
});